\chapter{Symbolic Domain Subset Testing\label{chap:SymbolicDomainSubsetTesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Whether an assignment statement is well-typed depends on whether the dynamic domain of the
right hand side type is contained in the dynamic domain of the left hand side type,
for any given dynamic environment.

\begin{definition}[Domain Subset]
For any given types $\vt$ and $\vs$ and static environment $\tenv$,
we say that $\vt$ is a \emph{domain subset} of $\vs$ in $\tenv$,
if the following condition holds:
\hypertarget{def-domainsubset}{}
\begin{equation}
\begin{array}{l}
\domainsubset(\tenv, \vt, \vs) \triangleq \\
\qquad \forall \denv\in\dynamicenvs.\
\dynamicdomain((\tenv, \denv), \vt) \subseteq \dynamicdomain((\tenv, \denv), \vs) \enspace.
\end{array}
\end{equation}
\end{definition}

For example, consider the assignment
\begin{center}
\texttt{var x : $\overname{\texttt{integer\{1,2,3\}}}{\vs}$ = ARBITRARY : $\overname{\texttt{integer\{1,2\}}}{\vt}$;}
\end{center}

It is well-typed, since the dynamic domain of \verb|integer{1,2,3}| is\\
$\{\nvint(1), \nvint(2), \nvint(3)\}$ in every dynamic environment, which is a superset of
the dynamic domain of \verb|integer{1,2}|, which is $\{\nvint(1), \nvint(2)\}$ in every dynamic environment.

Since dynamic domains are potentially infinite, this requires \emph{symbolic reasoning}.
Furthermore, since any (\symbolicallyevaluable{}) expressions may appear inside integer and bitvector
types, domain subset testing is undecidable.
We therefore approximate domain subset testing \emph{conservatively} via the predicate $\symdomsubsettest(\tenv, \vt, \vs)$.

\hypertarget{def-symdomsubsettest}{}
\begin{definition}[Sound Domain Subset Test]
A predicate
\[
  \symdomsubsettest(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs}) \aslto \Bool
\]
is \emph{sound} if the following condition holds:
\begin{equation}
  \begin{array}{l}
  \forall \vt,\vs\in\ty.\ \tenv\in\staticenvs. \\
  \;\;\;\; \symdomsubsettest(\tenv, \vt, \vs) \typearrow \True \;\Longrightarrow\; \domainsubset(\tenv, \vt, \vs)  \enspace.
  \end{array}
\end{equation}
\end{definition}

That is, if a sound domain subset test returns a positive answer, it means that
$\vt$ is definitely a domain subset of $\vs$ in the static environment $\tenv$.
This is referred to as a \emph{true positive}.
However, a negative answer means one of two things:
\begin{description}
  \item[True Negative:] indeed, $\vt$ is not a domain subset of $\vs$ in the static environment $\tenv$; or
  \item[False Negative:] the symbolic reasoning is unable to decide.
\end{description}

In other words, $\symdomsubsettest(\tenv, \vt, \vs)$ errs on the \emph{safe side} ---
it never answers $\True$ when the real answer is $\False$, which would (undesirably)
determine the following statement as well-typed:
\begin{center}
\texttt{var x : $\overname{\texttt{integer\{1,2\}}}{\vs}$ = ARBITRARY : $\overname{\texttt{integer}}{\vt}$;}
\end{center}

A sound but trivial domain subset test is one that always returns $\False$.
However, that would make all assignments be considered as not well-typed.
Indeed, it has the maximal set of false negatives.
Reducing the set of false negatives requires stronger symbolic reasoning algorithms,
which inevitably leads to higher computational complexity.
%
The symbolic domain subset test in \chapref{SymbolicDomainSubsetTesting}
attempts to accept a large enough set of true positives, based on empirical trial and error,
while maintaining the computational complexity of the symbolic reasoning relatively low.
%
In particular, it serves as the definitive domain subset test that must be utilized
by any implementation of the ASL type system.

This chapter is concerned with implementing a \hyperlink{def-symdomsubsettest}{sound domain subset test}
for \integertypesterm{} and \bitvectortypesterm, as defined above and as employed by \\
\TypingRuleRef{SubtypeSatisfaction}.
This is technically achieved by first transforming types (in the case of \integertypesterm{})
and width expressions (in the case of \bitvectortypesterm{}) into symbolic representations
that we refer to as \emph{symbolic domains} and then checking subsumption over the symbolic domains.

\section{Symbolic Domains}
\hypertarget{def-symbolicdomain}{}

We define the \emph{symbolic domain} datatype, reusing $\intconstraint$ from the untyped AST,
as follows:
\hypertarget{def-symdom}{}
\hypertarget{def-finite}{}
\[
  \begin{array}{rcl}
  \symdom       &\derives & \Finite(\powfin{\Z} \setminus \emptyset) \hypertarget{def-constraineddom}{}\\
                &|        & \ConstrainedDom(\intconstraint) \hypertarget{def-symdomortop}{} \hypertarget{def-top}{}\\
  \symdomortop  &\derives & \Top \hypertarget{def-subdomains}{}\\
                &|        & \Subdomains(\symdom^+)
  \end{array}
\]

\begin{itemize}
  \item We refer to an element of the form $\Finite(S)$ as a \emph{symbolic finite set integer domain},
        which represents the non-empty set of integers $S$;
  \item We refer to an element of the form $\ConstrainedDom(\vc)$ as a \emph{symbolic constrained integer domain},
        which represents the set of integers given by the constraint $\vcs$; and
  \item We refer to an element of the form $\Top$ as a \emph{symbolic unconstrained integer domain},
        which represents the set of all integers.
\end{itemize}

\section{Symbolic Reasoning}

The main rule is of this chapter is \TypingRuleRef{SymdomSubsetUnions}, which defines the function
$\symdomsubsetunions$.

Other helper rules are as follows:
\begin{itemize}
  \item \TypingRuleRef{SymdomNormalize}
  \item \TypingRuleRef{SymdomOfType}
  \item \TypingRuleRef{SymdomOfWidthExpr}
  \item \TypingRuleRef{SymdomOfConstraint}
  \item \TypingRuleRef{SymdomEval}
  \item \TypingRuleRef{SymdomSubset}
  \item \TypingRuleRef{ApproxConstraints}
  \item \TypingRuleRef{ApproxConstraint}
  \item \TypingRuleRef{ApproxExprMin}
  \item \TypingRuleRef{ApproxExprMax}
  \item \TypingRuleRef{ApproxBottomTop}
  \item \TypingRuleRef{IntsetToConstraints}
  \item \TypingRuleRef{ApproxExpr}
  \item \TypingRuleRef{ApproxType}
  \item \TypingRuleRef{ConstraintBinop}
  \item \TypingRuleRef{ApplyBinopExtremities}
  \item \TypingRuleRef{PossibleExtremitiesLeft}
  \item \TypingRuleRef{PossibleExtremitiesRight}
  \item \TypingRuleRef{ConstraintPow}
  \item \TypingRuleRef{ConstraintMod}
\end{itemize}

\TypingRuleDef{SymdomSubsetUnions}
\hypertarget{def-symdomsubsetunions}{}
The function
\[
\symdomsubsetunions(
  \overname{\staticenvs}{\tenv},
  \overname{\symdomortop}{\sdone},
  \overname{\symdomortop}{\sdtwo}) \aslto \overname{\Bool}{\vb}
\]
conservatively tests whether the set of integers represented by $\sdone$
is a subset of the set of integers represented by $\sdtwo$,
in the context of the static environment $\tenv$,
yielding the result in $\vb$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{right\_top}
  \begin{itemize}
    \item $\sdtwo$ is $\Top$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item \AllApplyCase{left\_top\_right\_not\_top}
  \begin{itemize}
    \item $\sdone$ is $\Top$;
    \item $\sdtwo$ is not $\Top$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\symdomsone$ is a list of symbolic domains $\symdomsone$;
    \item $\symdomstwo$ is a list of symbolic domains $\symdomstwo$;
    \item applying $\symdomnormalize$ to $\symdomsone$ yields $\symdomsonenorm$;
    \item applying $\symdomnormalize$ to $\symdomstwo$ yields $\symdomstwonorm$;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if for every symbolic domain $\vsone$
          in $\symdomsonenorm$ there exists a symbolic domain $\vstwo$ in
          $\symdomstwonorm$ such that \\
          $\symdomsubset$ holds for $\vsone$ and $\vstwo$ in $\tenv$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[right\_top]{}{
  \symdomsubsetunions(\tenv, \sdone, \overname{\Top}{\sdtwo}) \typearrow
  \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[left\_top\_right\_not\_top]{
  \sdone \neq \Top
}{
  \symdomsubsetunions(\tenv, \overname{\Top}{\sdone}, \sdtwo) \typearrow
  \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \symdomnormalize(\symdomsone) \typearrow \symdomsonenorm\\
  \symdomnormalize(\symdomstwo) \typearrow \symdomstwonorm\\
  {
  \begin{array}{rcl}
  \vb &\eqdef& \forall \vsone\in\symdomsonenorm.\ \exists \vstwo\in\symdomstwonorm.\\
      &      & \symdomsubset(\tenv, \vsone, \vstwo)
  \end{array}
  }
}{
  \symdomsubsetunions(\tenv, \overname{\Subdomains(\symdomsone)}{\sdone}, \overname{\Subdomains(\symdomstwo)}{\sdtwo}) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{SymdomNormalize}
\hypertarget{def-symdomnormalize}{}
The function
\[
\symdomnormalize(\overname{\symdom^+}{\symdoms}) \aslto \overname{\symdom^+}{\newsymdoms}
\]
transforms the list of symbolic domain $\symdoms$ into an equivalent list of symbolic domains $\newsymdoms$
(in the sense that they both represent the same set of integers)
where all symbolic finite set integer domains are merged into a single symbolic finite set integer domain
whose set of integers is the union of the sets of integers in the merged symbolic finite set integer domains.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\others$}{the sublist of $\symdoms$ consisting of symbolic domains other than
        symbolic finite set integer domains};
  \item \Proseeqdef{$\vfinitedomains$}{the sublist of $\symdoms$ consisting of symbolic finite set integer domains};
  \item \Proseeqdef{$\vxs$}{the union of sets in each symbolic finite set integer domain of \\
        $\vfinitedomains$};
  \item \Proseeqdef{$\newsymdoms$}{
        the list with \head{} $\Finite(\vxs)$ and \tail{} $\others$, if $\vxs$ is non-empty, and
        $\others$, otherwise}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \others = [\vs \in \symdoms \;|\; \configdomain{\vs} \neq \Finite]\\
  \vfinitedomains = [\vs \in \symdoms \;|\; \configdomain{\vs} = \Finite]\\
  \vxs \eqdef \bigcup_{\Finite(\vs) \in \vfinitedomains} \vs\\\\
  \newsymdoms \eqdef \choice{\vxs \neq \emptyset}{[\Finite(\vxs)] \concat \others}{\others}
}{
  \symdomnormalize(\symdoms) \typearrow \newsymdoms \newsymdoms
}
\end{mathpar}

\TypingRuleDef{SymdomOfType}
\hypertarget{def-symdomoftype}{}
The function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdomortop}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.
It assumes its input type has an \underlyingtype{} which is an integer.
\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int\_unconstrained}
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type;
    \item \Proseeqdef{$\vd$}{$\Top$, which intuitively represents the entire set of integers}.
  \end{itemize}

  \item \AllApplyCase{int\_parameterized}
  \begin{itemize}
    \item $\vt$ is the \parameterizedintegertype\ for the identifier $\id$;
    \item define $\vd$ as the singleton list consisting of the
          symbolic constrained integer domain with a single constraint for the variable expression for $\id$,
          that is, \\ $\ConstrainedDom(\ConstraintExact(\EVar(\id)))$.
  \end{itemize}

  \item \AllApplyCase{int\_well\_constrained}
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\symdomofconstraint$ to $\tenv$ and $\vc_\vi$, for every \Proselistrange{$\vi$}{$\vcs$},
          yields $\vd_\vi$;
    \item \Proseeqdef{$\vd$}{the list symbolic integer domains consisting of $\vd_\vi$, for every \Proselistrange{$\vi$}{$\vcs$}}.
  \end{itemize}

  \item \AllApplyCase{t\_named}
  \begin{itemize}
    \item $\vt$ is the named type for identifier $\id$;
    \item applying $\makeanonymous$ to $\vt$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ in $\tenv$ yields $\vd$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[int\_unconstrained]{}{ \symdomoftype(\tenv, \overname{\unconstrainedinteger}{\vt}) \typearrow
 \overname{\Top}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_parameterized]{}{
  \symdomoftype(\tenv, \overname{\TInt(\parameterized(\id))}{\vt}) \typearrow \\
  \overname{\Subdomains([\ConstrainedDom(\ConstraintExact(\EVar(\id)))])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained]{
  \vi\in\listrange(\vcs): \symdomofconstraint(\tenv, \vcs[\vi]) \typearrow \vd_\vi\\
  \vc \eqdef \vi\in\listrange(\vcs) \vd_\vi
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\Subdomains(\vis)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  \vt = \TNamed(\id)\\
  \makeanonymous(\vt) \typearrow \vtone\\
  \symdomoftype(\tenv, \vtone) \typearrow \vd
}{
  \symdomoftype(\tenv, \vt) \typearrow \vd
}
\end{mathpar}

\TypingRuleDef{SymdomOfWidthExpr}
\hypertarget{def-symdomofwidthexpr}{}
The function
\[
\symdomofwidthexpr(
  \overname{\expr}{\ve}
) \aslto
\overname{\symdomortop}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$,
where $\ve$ is assumed to be the expression conveying the width of a \bitvectortypeterm.

\ProseParagraph
\Proseeqdef{$\vd$}{the singleton list for the constrained symbolic integer domain
for the exact constraint for the expression $\ve$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \symdomofwidthexpr(\ve) \typearrow \overname{\Subdomains([\ \ConstrainedDom(\ConstraintExact(\ve))\ ])}{\vd}
}
\end{mathpar}

\TypingRuleDef{SymdomOfConstraint}
\hypertarget{def-symdomofconstraint}{}
The function
\[
  \symdomofconstraint(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\intconstraint}{\vc}
  ) \aslto
  \overname{\symdom}{\vd}
\]
transforms an integer constraint $\vc$ into a symbolic domain $\vd$
in the context of the static environment $\tenv$.
It produces $\Top$ when the expressions involved in the integer constraints cannot be simplified
to integers.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is a single expression constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\symdomeval$ to $\ve$ in $\tenv$ yields $\vv$;
    \item define $\vd$ as constrained symbolic integer domain for $\vc$
          ($\ConstrainedDom(\vc)$) if $\vv$ is $\Top$
          and otherwise as the finite symbolic integer domain for the singleton set for $\vv$ ($\Finite(\{n\})$).
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\symdomeval$ to $\veone$ in $\tenv$ yields $\vvone$;
    \item applying $\symdomeval$ to $\vetwo$ in $\tenv$ yields $\vvtwo$;
    \item define $\vd$ as the constrained symbolic integer domain for $\vc$ if either $\vvone$ or $\vvtwo$
          are $\Top$ ($\ConstrainedDom(\vc)$) and otherwise the finite symbolic integer domain for the
          set integers that are both greater or equal to $\vvone$ and less than or equal to $\vvtwo$
          ($\Finite(\{ n \;|\; \vvone \leq n \leq \vvtwo\})$).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \symdomeval(\tenv, \ve) \typearrow \vv\\
  \vd \eqdef \choice{\vv = \Top}{\ConstrainedDom(\vc)}{\Finite(\{\vv\})}
}{
  \symdomofconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \symdomeval(\tenv, \veone) \typearrow \vvone\\
  \symdomeval(\tenv, \vetwo) \typearrow \vvtwo\\
  \vd \eqdef \choice{\vvone = \Top \lor \vvtwo = \Top}{\ConstrainedDom(\vc)}{\Finite(\{ n \;|\; \vvone \leq n \leq \vvtwo\})}
}{
  \symdomofconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vd
}
\end{mathpar}

\TypingRuleDef{SymdomEval}
\hypertarget{def-symdomeval}{}
The function
\[
\symdomeval(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\Z}{n} \cup \{\Top\}
\]
\symbolicallysimplifies\ the \underline{integer-typed} expression $\ve$ and returns the resulting integer or $\Top$ if
the result of the simplification is not an integer.

We assume that $\ve$ has been annotated as it is part of the constraint for an integer type,
and therefore applying $\normalize$ to it does not yield a \typingerrorterm{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{integer}
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the integer literal for $n$.
  \end{itemize}

  \item \AllApplyCase{top}
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\top$.
    \item the result is $\Top$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[integer]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \lint(n)
}{
  \symdomeval(\tenv, \ve) \typearrow n
}
\and
\inferrule[top]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \top
}{
  \symdomeval(\tenv, \ve) \typearrow \Top
}
\end{mathpar}

\TypingRuleDef{SymdomSubset}
\hypertarget{def-symdomsubset}{}
The function
\[
  \symdomsubset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\symdom}{\cdone} \aslsep
    \overname{\symdom}{\cdtwo}
  ) \aslto
  \overname{\Bool}{\vb}
\]
conservatively tests whether the values represented by the \symbolicdomain\ $\cdone$
is a subset of the values represented by the \symbolicdomain\ $\cdtwo$ in any environment
consisting of the static environment $\tenv$, yielding the result in $\vb$.

The test first \emph{overapproximates} $\visone$ by a set of integers $\vsone$.
That is, $\vsone$ represents a superset of the set of numbers represented by $\visone$.
Notice that this can always be done as $\N$ overapproximates any set of integers.
%
Second, the test \emph{underapproximates} $\vistwo$ by a set of integers $\vstwo$.
That is, $\vstwo$ represents a superset of the set of numbers represented by $\visone$.
Notice that this can always be done as the empty set underapproximates any set of integers.
%
The test concludes by checking whether $\vsone$ is a subset of $\vstwo$,
which if true implies that the set of numbers represented by $\visone$ is a subset of the
set of numbers represented by $\vstwo$ (in any environment).
A negative answer on the other hand means that the
test is unable to conclude subsumption.

\hypertarget{def-Under}{}
\hypertarget{def-Over}{}
\hypertarget{def-approximationdirectionterm}{}
In the following, we use the symbol $\Over$ to stand for \emph{overapproximation}
and the symbol $\Under$ to stand for \emph{underapproximation}.
We refer such a symbol as an \approximationdirectionterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{finite\_finite}
  \begin{itemize}
    \item $\cdone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vstwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item define $\vb$ as $\True$ if and only if $\vsone$ is a subset of $\vstwo$.
  \end{itemize}

  \item \AllApplyCase{constrained\_constrained\_equal}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item applying $\constraintequal$ to $\tenv$, $\vcone$, and $\vctwo$ yields $\True$;
    \item \Proseeqdef{$\vb$}{$\True$}.
  \end{itemize}

  \item \AllApplyCase{constrained\_constrained\_non\_equal}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item applying $\constraintequal$ to $\tenv$, $\vcone$, and $\vctwo$ yields $\False$;
    \item \Proseapproxconstraint{$\tenv$}{$\vcone$}{$\Over$}{$\vsone$};
    \item \Proseapproxconstraint{$\tenv$}{$\vctwo$}{$\Under$}{$\vstwo$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{finite\_constrained}
  \begin{itemize}
    \item $\visone$ is a finite symbolic integer domain for the set of integers $\vsone$, that is, $\Finite(\vsone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item \ProseapproxconstraintsUnder{$\tenv$}{$\vctwo$}{$\vstwo$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{constrained\_finite}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item \ProseapproxconstraintsOver{$\tenv$}{$\vcone$}{$\vsone$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[finite\_finite]{}{
  \symdomsubset(\tenv, \overname{\Finite(\vsone)}{\cdone}, \overname{\Finite(\vstwo)}{\cdtwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_constrained\_equal]{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \True
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\cdone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\True}{\vb}
}
\end{mathpar}

% Transliteration comment: instead of the symbol CannotOverApproximate, we use the set of all integers.
\begin{mathpar}
\inferrule[constrained\_constrained\_non\_equal]{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False\\\\
  \approxconstraint(\tenv, \Over, \vcone) \typearrow \vsone\\
  \approxconstraint(\tenv, \Under, \vctwo) \typearrow \vstwo
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\cdone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_constrained]{
  \approxconstraints(\tenv, \Under, \vctwo) \typearrow \vstwo
}{
  \symdomsubset(\tenv, \overname{\Finite(\cdone)}{\vsone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_finite]{
  \approxconstraints(\tenv, \Over, \vcone) \typearrow \vsone
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\TypingRuleDef{ApproxConstraints}
\hypertarget{def-approxconstraints}{}
The function
\[
\approxconstraints(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\intconstraint^+}{\cs}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
conservatively approximates the non-empty list of constraints $\cs$ by a set of integers $\vs$.
The approximation is over all environments consisting of the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{over}
  \begin{itemize}
    \item $\vapprox$ is $\Over$;
    \item \Proseapproxconstraint{$\tenv$}{$\vc$}{$\Over$}{$\vs_\vc$}, for every constraint $\vc$ in $\cs$\ProseTerminateAs{\Z};
    \item \Proseeqdef{$\vs$}{the union of all sets $\vs_\vc$, for every constraint $\vc$ in $\cs$}.
  \end{itemize}

  \item \AllApplyCase{under}
  \begin{itemize}
    \item $\vapprox$ is $\Under$;
    \item \Proseapproxconstraint{$\tenv$}{$\vc$}{$\Under$}{$\vs_\vc$}, for every constraint $\vc$ in $\cs$;
    \item \Proseeqdef{$\vs$}{the intersection of all sets $\vs_\vc$, for every constraint $\vc$ in $\cs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[over]{
  \vc \in \cs: \approxconstraint(\tenv, \Over, \vc) \typearrow \vs_\vc \terminateas \Z
}{
  \approxconstraints(\tenv, \overname{\Over}{\vapprox}, \cs) \typearrow
  \overname{\bigcup_{\vc \in \cs} \vs_\vc}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[under]{
  \vc \in \cs: \approxconstraint(\tenv, \vapprox, \vc) \typearrow \vs_\vc
}{
  \approxconstraints(\tenv, \vapprox, \cs) \typearrow
  \overname{\bigcap_{\vc \in \cs} \vs_\vc}{\vs}
}
\end{mathpar}
\CodeSubsection{\ApproxConstraintsBinopBegin}{\ApproxConstraintsBinopEnd}{../Typing.ml}

\TypingRuleDef{ApproxConstraint}
\hypertarget{def-approxconstraint}{}
The function
\[
\approxconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\intconstraint}{\vc}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
conservatively approximates the constraint $\vc$ by a set of integers $\vs$.
The approximation is over all environments that consist of the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ExampleDef{Approximating Constraints}
The specification in \listingref{ApproxConstraint} is well-typed,
showing how constraints are overapproximated and underapproximated.
\ASLListing{Approximating constraints}{ApproxConstraint}{\typingtests/TypingRule.ApproxConstraint.asl}

In the following inference rules, we use $\leq$ to compare both integers to integers
and integers to infinity symbols. Specifically, the following hold:
$\forall z\in\Z.\ -\infty < z$ and $\forall z\in\Z.\ z < +\infty$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an \Proseexactconstraint{\ve};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\ve$}{$\vs$}\ProseTerminateAs{\Z}.
  \end{itemize}

  \item \AllApplyCase{range\_over}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmin{$\tenv$}{$\veone$}{$\vzone$}\ProseTerminateAs{\Z};
    \item \Proseapproxexprmax{$\tenv$}{$\vetwo$}{$\vztwo$}\ProseTerminateAs{\Z};
    \item \Proseeqdef{$\vsinterval$}{the set of integers greater or equal to $\vzone$ and
          less than or equal to $\vztwo$};
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vsbottomtop$;
    \item \Proseeqdef{$\vs$}{$\vsinterval$ if $\vzone$ is less than or equal to $\vztwo$ and $\vsbottomtop$, otherwise}.
  \end{itemize}

  \item \AllApplyCase{range\_under}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmax{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmin{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item \Proseeqdef{$\vsinterval$}{the set of integers greater or equal to $\vzone$ and
          less than or equal to $\vztwo$};
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vsbottomtop$;
    \item \Proseeqdef{$\vs$}{$\vsinterval$ if $\vzone$ is less than or equal to $\vztwo$ and $\vsbottomtop$, otherwise}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \approxexpr(\tenv, \vapprox, \ve) \typearrow \vs \terminateas \Z
}{
  \approxconstraint(\tenv, \vapprox, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vs
}
\end{mathpar}

% Transliteration note: splitting the case of ranges based on 'approx' to avoid excessive
% use of conditionals in rules (i.e., choice functions).
\begin{mathpar}
\inferrule[range\_over]{
  \vapprox = \Over\\
  \approxexprmin(\tenv, \veone) \typearrow \vzone \terminateas \Z\\\\
  \approxexprmax(\tenv, \vetwo) \typearrow \vztwo \terminateas \Z\\\\
  \vsinterval \eqdef \{ \vz \;|\; \vzone \leq \vz \leq \vztwo \}\\
  \approxbottomtop(\vapprox) \typearrow \vsbottomtop\\
  \vs \eqdef \choice{\vzone \leq \vztwo}{\vsinterval}{\vsbottomtop}
}{
  \approxconstraint(\tenv, \vapprox, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_under]{
  \vapprox = \Under\\
  \approxexprmax(\tenv, \veone) \typearrow \vzone\\
  \approxexprmin(\tenv, \vetwo) \typearrow \vztwo\\
  \vsinterval \eqdef \{ \vz \;|\; \vzone \leq \vz \leq \vztwo \}\\
  \approxbottomtop(\vapprox) \typearrow \vsbottomtop\\
  \vs \eqdef \choice{\vzone \leq \vztwo}{\vsinterval}{\vsbottomtop}
}{
  \approxconstraint(\tenv, \vapprox, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ApproxExprMin}
\hypertarget{def-approxexprmin}{}
% Transliteration note: instead of exceptions, I'm using infinity symbols.
The function
\[
\approxexprmin(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Z \cup \{-\infty\}}{\vz}
\]
approximates the minimal integer represented by the expression $\ve$
in any environment consisting of the static environment
$\tenv$. The result, yielded in $\vz$ is either an integer or $-\infty$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseapproxexpr{$\tenv$}{$\Over$}{$\ve$}{$\vs$};
  \item \Proseeqdef{$\vz$}{the minimal integer in $\vz$ or $-\infty$ if there is no such integer}.
\end{itemize}

\FormallyParagraph
\hypertarget{def-mininfty}{}
In the following rule, the helper function
\[
\mininfty : \pow{\Z} \aslto \Z \cup \{-\infty\}
\]
returns the minimal integer
for a given set of integers, if there is one, and $-\infty$, otherwise.

\begin{mathpar}
\inferrule{
  \approxexpr(\tenv, \Over, \ve) \typearrow \vs
}{
  \approxexprmin(\tenv, \ve) \typearrow \overname{\mininfty(\vs)}{\vz}
}
\end{mathpar}

\TypingRuleDef{ApproxExprMax}
\hypertarget{def-approxexprmax}{}
The function
\[
\approxexprmax(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Z \cup \{+\infty\}}{\vz}
\]
approximates the maximal integer represented by the expression $\ve$
in any environment consisting of the static environment
$\tenv$. The result, yielded in $\vz$ is either an integer or $+\infty$.

\hypertarget{def-maxinfty}{}
In the following rule, the helper function
\[
\maxinfty : \pow{\Z} \aslto \Z \cup \{+\infty\}
\]
returns the maximal integer
for a given set of integers, if there is one, and $+\infty$, otherwise.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseapproxexpr{$\tenv$}{$\Over$}{$\ve$}{$\vs$};
  \item \Proseeqdef{$\vz$}{the maximal integer in $\vz$ or $+\infty$ if there is no such integer}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \approxexpr(\tenv, \Over, \ve) \typearrow \vs
}{
  \approxexprmax(\tenv, \ve) \typearrow \overname{\maxinfty(\vs)}{\vz}
}
\end{mathpar}

\TypingRuleDef{ApproxBottomTop}
\hypertarget{def-approxbottomtop}{}
The function
\[
\approxbottomtop(\overname{\{\Under, \Over\}}{\vapprox}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
returns in $\vs$ either the empty set or the set of all integers,
depending on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\ProseEqdef{$\vs$}{the empty set if $\vapprox$ is $\Under$ and the set of all integers
if $\vapprox$ is $\Over$.}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \approxbottomtop(\vapprox) \typearrow \overname{\choice{\vapprox = \Under}{\emptyset}{\Z}}{\vs}
}
\end{mathpar}

\TypingRuleDef{IntsetToConstraints}
\hypertarget{def-intsettoconstraints}{}
The function
\[
\intsettoconstraints(\overname{\powfin{\Z}}{\vs}) \aslto \overname{\intconstraint^*}{\cs}
\]
converts a finite set of integers $\vs$ into an equivalent list of constraints.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\intervals$}{the set of maximal intervals in $\vs$};
  \item \Proseeqdef{$\cs$}{the list of constraints where for each interval $a..b$ in $\intervals$,
        there is an exact constraint for $a$ if $a$ is equal to $b$ and a range constraint \\
        $\AbbrevConstraintRange{\ELInt{a}}{\ELInt{b}}$, otherwise}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \intervals \eqdef \{ a..b \;|\; a..b \in \vs \land \forall (c..d) \in \vs.\ a..b \not\subseteq c..d\}\\
  \cs \eqdef [a..b \in \intervals: \choice{a=b}{
    \AbbrevConstraintExact{\ELInt{a}}}{\AbbrevConstraintRange{\ELInt{a}}{\ELInt{b}}}]
}{
  \intsettoconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\TypingRuleDef{ApproxExpr}
\hypertarget{def-approxexpr}{}
The function
\[
\approxexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\expr}{\ve}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
conservatively approximates the expression $\ve$ by a set of integers $\vs$
in the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{literal\_int}
  \begin{itemize}
    \item $\ve$ is a literal expression for the integer $\vz$;
    \item \Proseeqdef{$\vs$}{the singleton set for $\vz$}.
  \end{itemize}

  \item \AllApplyCase{literal\_non\_int}
  \begin{itemize}
    \item $\ve$ is a literal expression for a non-integer value;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}

  \item \AllApplyCase{var\_over}
  \begin{itemize}
    \item $\ve$ is a \variableexpression{$\vx$};
    \item $\vapprox$ is $\Over$;
    \item \Prosetypeof{$\tenv$}{$\vx$}{$\vt$};
    \item \Proseapproxtype{$\tenv$}{$\Over$}{$\vt$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{var\_under}
  \begin{itemize}
    \item $\ve$ is a \variableexpression{$\vx$};
    \item $\vapprox$ is $\Under$;
    \item \Proseeqdef{$\vs$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{unop}
  \begin{itemize}
    \item $\ve$ is a \unopexpression{$\op$}{$\vep$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vep$}{$\vsp$}\ProseTerminateAs{\Z};
    \item \Proseeqdef{$\vs$}{the set obtained by applying $\unopliterals$ to $\op$ and
      the integer literal for every integer in $\vsp$}.
  \end{itemize}

  \item \AllApplyCase{binop}
  \begin{itemize}
    \item $\ve$ is a \binopexpression{$\op$}{$\veone$}{$\vetwo$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\veone$}{$\vsone$}\ProseTerminateAs{\Z};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$}\ProseTerminateAs{\Z};
    \item applying $\annotateconstraintbinop$ to $\tenv$, $\vsone$, and $\vstwo$ yields $(\vsp, \plf)$;
    \item applying $\approxconstraints$ to $\tenv$, $\vapprox$, and $\vsp$ yields $\vsapprox$;
    \item \Proseeqdef{$\vs$}{
      $\vsapprox$ if $\plf$ is $\PrecisionFull$ or $\plf$ is $\PrecisionLost$ and $\vapprox$ is $\Under$,
      and as the set of all integers otherwise}.
  \end{itemize}

  \item \AllApplyCase{cond}
  \begin{itemize}
    \item $\ve$ is a \condexpression{any}{$\vetwo$}{$\vethree$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$}\ProseTerminateAs{\Z};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vethree$}{$\vsthree$}\ProseTerminateAs{\Z};
    \item \Proseeqdef{$\vs$}{the union of $\vstwo$ and $\vsthree$ if $\vapprox$ is $\Over$
    and the intersection of $\vstwo$ and $\vsthree$ if $\vapprox$ is $\Under$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\ve$ is an expression that is neither of the following types of expressions:
          \literalexpressionterm, \variableexpressionterm, \unopexpressionterm, \binopexpressionterm,
          or a \condexpressionterm;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[literal\_int]{}{
  \approxexpr(\tenv, \vapprox, \overname{\ELInt{\vz}}{\ve}) \typearrow \overname{\{\vz\}}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[literal\_non\_int]{
  \astlabel(\vl) \neq \lint\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxexpr(\tenv, \vapprox, \overname{\ELiteral(\vl)}{\ve}) \typearrow \vs
}
\end{mathpar}

In the following inference rule, the application of $\typeof$ is guaranteed not
to result in a \typingerrorterm{}, since $\symdomsubset$ is only applied to annotated
types.
\begin{mathpar}
\inferrule[var\_over]{
  \typeof(\tenv, \vx) \typearrow \vt\\
  \approxtype(\tenv, \Over, \vt) \typearrow \vs
}{
  \approxexpr(\tenv, \overname{\Over}{\vapprox}, \overname{\EVar(\vx)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[var\_under]{}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \overname{\EVar(\vx)}{\ve}) \typearrow \overname{\emptyset}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unop]{
  \approxexpr(\tenv, \vapprox, \vep) \typearrow \vsp \terminateas \Z\\\\
  \vs \eqdef \{ \unopliterals(\op, \lint(\vz)) \;|\; \vz \in \vsp\}
}{
  \approxexpr(\tenv, \vapprox, \overname{\EUnop(\op, \vep)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop]{
  \approxexpr(\tenv, \vapprox, \veone) \typearrow \vsone \terminateas \Z\\\\
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo \terminateas \Z\\\\
  \annotateconstraintbinop(\tenv, \vsone, \vstwo) \typearrow (\vsp, \plf)\\
  \approxconstraints(\tenv, \vapprox, \vsp) \typearrow \vsapprox\\
  {
  \vs \eqdef
  \begin{cases}
    \vsapprox & \text{if }\plf = \PrecisionFull \lor (\plf = \PrecisionLost \land \vapprox = \Under)\\
    % Transliteration comment: instead of the symbol CannotOverApproximate, we use the set of all integers.
    \Z        & \text{if }\plf = \PrecisionLost \land \vapprox = \Over
  \end{cases}
  }
}{
  \approxexpr(\tenv, \vapprox, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[cond]{
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo \terminateas \Z\\\\
  \approxexpr(\tenv, \vapprox, \vethree) \typearrow \vsthree \terminateas \Z\\\\
  \vs \eqdef \choice{\vapprox = \Over}{\vstwo \cup \vsthree}{\vstwo \cap \vsthree}
}{
  \approxexpr(\tenv, \vapprox, \overname{\ECond(\Ignore, \vetwo, \vethree)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop, \ECond\}\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxexpr(\tenv, \vapprox, \ve) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ApproxType}
\hypertarget{def-approxtype}{}
The function
\[
\approxtype(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\ty}{\vt}) \aslto
\overname{\pow{\Z}}{\vs}
\]
conservatively approximates the type $\vt$ by a set of integers $\vs$
in the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{named}
  \begin{itemize}
    \item $\vt$ is a \namedtype;
    \item \Prosemakeanonymous{$\tenv$}{$\vt$}{$\vtp$};
    \item \Proseapproxtype{$\tenv$}{$\vapprox$}{$\vtp$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{int\_wellconstrained}
  \begin{itemize}
    \item $\vt$ is a \wellconstrainedintegertype\ with the list of integer constraints $\cs$;
    \item \Proseapproxconstraints{$\tenv$}{$\vapprox$}{$\cs$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\vt$ is neither a \namedtypeterm\ nor a \wellconstrainedintegertype;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[named]{
  \isnamed(\vt)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtp\\
  \approxtype(\tenv, \vapprox, \vtp) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vt = \TInt(\wellconstrained(\cs))\\
  \approxconstraints(\tenv, \vapprox, \cs) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \neg\isnamed(\vt) \land \neg\iswellconstrainedinteger(\vt)\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ConstraintBinop}
\hypertarget{def-constraintbinop}{}
The function
\[
\constraintbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
)
\aslto \overname{\constraintkind}{\newcs}
\]
symbolically applies the binary operation $\op$ to the lists of integer constraints $\csone$ and $\cstwo$,
yielding the integer constraints $\vics$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{extremities}
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\MUL$, $\PLUS$, $\MINUS$, $\SHR$, or $\SHL$;
    \item applying $\applybinopextremities$ to every pair of constraints \\
          $\csone[\vi]$ and $\cstwo[\vj]$ where $\vi\in\listrange(\csone)$ and
          $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item \AllApplyCase{mod}
  \begin{itemize}
    \item $\op$ is $\MOD$;
    \item applying $\constraintmod$ to $\cstwo[\vj]$, for every $\vj\in\listrange(\cstwo)$, yields $\vc_\vj$;
    \item define $\newcs$ as $\vc_\vj$, for every $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item \AllApplyCase{pow}
  \begin{itemize}
    \item $\op$ is $\POW$;
    \item applying $\constraintpow$ to every pair of constraints $\csone[\vi]$ and $\cstwo[\vj]$
          where $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[extremities]{
  \op \in \{\DIV, \DIVRM, \MUL, \PLUS, \MINUS, \SHR, \SHL\}\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \applybinopextremities(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[mod]{
  \op = \MOD\\
  \vj\in\listrange(\cstwo): \constraintmod(\cstwo[\vj]) \typearrow \vc_\vj\\
  \newcs = [\vj\in\listrange(\cstwo): \vc_\vj]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow]{
  \op = \POW\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \constraintpow(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}
\CodeSubsection{\ConstraintBinopBegin}{\ConstraintBinopEnd}{../Typing.ml}

\TypingRuleDef{ApplyBinopExtremities}
\hypertarget{def-applybinopextremities}{}
The function
\[
\applybinopextremities(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}
) \aslto \overname{\intconstraint^*}{\newcs}
\]
yields a list of constraints $\newcs$ for the constraints $\vcone$ and $\vctwo$, which are needed to include
range constraints for cases where the binary operation $\op$ yields a dynamic error.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_exact}
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint for the binary expression $\AbbrevEBinop{\op}{\va}{\vc}$.
  \end{itemize}

  \item \AllApplyCase{range\_exact}
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item applying $\possibleextremitiesleft$ to $\op$, $\va$, and $\vb$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}$
          for each pair of expressions $(\vap, \vbp)$ in $\extpairs$.
  \end{itemize}

  \item \AllApplyCase{exact\_range}
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}$
          for each pair of expressions $(\vcp, \vdp)$ in $\extpairs$.
  \end{itemize}

  \item \AllApplyCase{range\_range}
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\va$, and $\vb$ yields $\extpairsab$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairscd$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}$
          for each pair of expressions
          $(\vap, \vbp)$ in $\extpairsab$
          and each pair of expressions
          $(\vcp, \vdp)$ in $\extpairscd$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[ \ConstraintExact(\AbbrevEBinop{\op}{\va}{\vc}) ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairs\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairs\\
  \newcs \eqdef [(\vcp, \vdp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairsab\\
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairscd\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairsab, (\vcp, \vdp) \in \extpairscd:
  \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\TypingRuleDef{PossibleExtremitiesLeft}
\hypertarget{def-possibleextremitiesleft}{}
The function
\[
\possibleextremitiesleft(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\va} \aslsep \overname{\expr}{\vb}
) \aslto \overname{(\expr\times\expr)^*}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\va$ and $\vb$, which are needed to form constraints
for cases where applying $\op$ to $\va$ and $\vb$ would lead to a dynamic error.

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{mul}
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\va, \va)$, $(\va, \vb)$, $(\vb, \va)$, and $(\vb, \vb)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\SHR$, $\SHL$, $\PLUS$, or $\MINUS$;
    \item define $\extpairs$ as the list consisting of $(\va, \vb)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesleft(\overname{\MUL}{\op}, \va, \vb) \typearrow \overname{[(\va, \va), (\va, \vb), (\vb, \va), (\vb, \vb)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \op \in \{\DIV, \DIVRM, \SHR, \SHL, \PLUS, \MINUS\}
}{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \overname{[(\va, \vb)]}{\extpairs}
}
\end{mathpar}

\TypingRuleDef{PossibleExtremitiesRight}
\hypertarget{def-possibleextremitiesright}{}
The function
\[
\possibleextremitiesright(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\vc} \aslsep \overname{\expr}{\vd}
) \aslto \overname{(\expr\times\expr)^*}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\vc$ and $\vd$, which are needed to form constraints
for cases where applying $\op$ to $\vc$ and $\vd$ would lead to a dynamic error.

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{plus}
  \begin{itemize}
    \item $\op$ is $\PLUS$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vd)$.
  \end{itemize}

  \item \AllApplyCase{minus}
  \begin{itemize}
    \item $\op$ is $\MINUS$;
    \item define $\extpairs$ as the list consisting of $(\vd, \vc)$.
  \end{itemize}

  \item \AllApplyCase{mul}
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vc)$, $(\vc, \vd)$, $(\vd, \vc)$, and $(\vd, \vd)$.
  \end{itemize}

  \item \AllApplyCase{shl\_shr}
  \begin{itemize}
    \item $\op$ is either $\SHL$ or $\SHR$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{0})$ and $(\ELInt{0}, \vd)$.
  \end{itemize}

  \item \AllApplyCase{div\_divrm}
  \begin{itemize}
    \item $\op$ is either $\DIV$ or $\DIVRM$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{1})$ and $(\ELInt{1}, \vd)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[plus]{}{
  \possibleextremitiesright(\overname{\PLUS}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[minus]{}{
  \possibleextremitiesright(\overname{\MINUS}{\op}, \vc, \vd) \typearrow \overname{[(\vd, \vc)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesright(\overname{\MUL}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vc), (\vc, \vd), (\vd, \vc), (\vd, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl\_shr]{
  \op \in \{\SHL, \SHR\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{0}), (\ELInt{0}, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_divrm]{
  \op \in \{\DIV, \DIVRM\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{1}), (\ELInt{1}, \vd)]}{\extpairs}
}
\end{mathpar}

\TypingRuleDef{ConstraintMod}
\hypertarget{def-constraintmod}{}
The function
\[
\constraintmod(\overname{\intconstraint}{\vc}) \aslto \overname{\intconstraint}{\newc}
\]
yields a range constraint $\newc$ from $0$ to the expression in $\vc$ that is maximal.
This is needed to apply the modulus operation to a pair of constraints.

\ExampleDef{Ill-typed Modulus Constraint Assignment}
In \listingref{typing-constraintmod}, the assignment to \texttt{z} is illegal, since the type
inferred for \texttt{z} is\\
\verb|integer{0..2}|.

\ASLListing{An ill-typed modulus constraint assignment}{typing-constraintmod}{\typingtests/TypingRule.ConstraintMod.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\veupper$}{
    $\ve$ if $\vc$ is a single constraint for $\ve$,
    and $\vb$ if $\vc$ is a range constraint for a pair of expressions, the second of which is $\vb$.
  };
  \item \Proseeqdef{$\veminusone$}{the binary expression subtracting $1$ from $\veupper$};
  \item \Proseeqdef{$\newc$}{a range constraint for the literal expression for $0$ for $\veminusone$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \veupper \eqdef \begin{cases}
      \ve & \vc = \ConstraintExact(\ve)\\
      \vb & \vc = \ConstraintRange(\Ignore, \vb)
    \end{cases}
  }\\
  \veminusone \eqdef \EBinop(\MINUS, \veupper, \ELInt{1})
}{
  \constraintmod(\vc) \typearrow \overname{\ConstraintRange(\ELInt{0}, \veminusone)}{\newc}
}
\end{mathpar}
\CodeSubsection{\ConstraintModBegin}{\ConstraintModEnd}{../Typing.ml}

\TypingRuleDef{ConstraintPow}
\hypertarget{def-constraintpow}{}
The function
\[
\constraintpow(\overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}) \aslto \overname{\intconstraint^+}{\newcs}
\]
yields a list of range constraints $\newcs$ that are needed to calculate the result of
applying a $\POW$ operation to the constraints $\vcone$ and $\vctwo$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_exact}
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vcone$ is the constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint
    for the expression \\ $\EBinop(\POW, \va, \vc)$.
  \end{itemize}

  \item \AllApplyCase{range\_exact}
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the constraint for the expression $\vc$;
    \item define $\vmac$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vc)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vc)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmac)$ and $\vmac$;
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{exact\_range}
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \va, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{range\_range}
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[\ \ConstraintExact(\EBinop(\POW, \va, \vc))\ ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \vmac \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vc)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vc}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmac)}{\vmac}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\va}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ConstraintPowBegin}{\ConstraintPowEnd}{../Typing.ml}
